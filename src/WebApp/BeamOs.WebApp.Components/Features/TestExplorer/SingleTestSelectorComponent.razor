@using BeamOs.StructuralAnalysis.Contracts.Common
@using BeamOs.Tests.Common
@using BeamOs.WebApp.EditorCommands
@using System.Collections.Immutable
@using static BeamOs.WebApp.Components.Features.TestExplorer.TestResultDisplayComponent

@inherits FluxorComponent

<MudDrawerHeader Class="flex flex-row p-0 h-fit min-h-4 items-center">
    <MudTooltip Text="Back to All Example Problems">
        <MudIconButton Icon="@Icons.Material.Filled.ArrowBack" OnClick="GoBack"></MudIconButton>
    </MudTooltip>
    <MudText Typo="Typo.h6" Class="grow text-center">Test Results</MudText>
    <div class="w-12"></div>
</MudDrawerHeader>

<div class="flex flex-col h-full w-full">

    @*     <MudGrid>
        <MudItem xs="3">

        </MudItem>
        <MudItem xs="9">

        </MudItem>
    </MudGrid> *@
    @* <div class="px-2">
        <MudText Typo="Typo.subtitle1" Color="Color.Primary">Id: @this.TestSelectorState.Value.SelectedObjectId</MudText>
    </div> *@

    @{
        int numFilteredTests = 0;
    }
    <MudExpansionPanels Class="grow" MultiExpansion="true" Outlined="false" Elevation="0" Dense="true">
        <MudList Class="grow" T="TestResult" SelectedValueChanged="SelectedTestInfoChanged">
            @foreach (var (objectType, idToResultsDict) in this.TestResults)
            {
                if (this.SelectedObjectType is not null && objectType != this.SelectedObjectType.Value)
                {
                    continue;
                }

                <MudExpansionPanel Expanded="true" Text="@(objectType + "s")" Class="text-nowrap text-clip mud-typography mud-typography-subtitle1 p-4">
                    <TitleContent>
                        <div class="d-flex">
                            <MudIcon Color="Color.Error" Icon="@Icons.Material.Filled.CheckCircleOutline" class="mr-3"></MudIcon>
                            <MudText><strong>@(objectType + "s")</strong></MudText>
                        </div>
                    </TitleContent>
                    <ChildContent>
                        @foreach (var (id, testResults) in idToResultsDict)
                        {
                            if (this.SelectedObjectId is not null && id != this.SelectedObjectId)
                            {
                                continue;
                            }

                            foreach (var result in testResults)
                            {
                                numFilteredTests++;
                                <MudListItem @onmouseover="() => MouseOver(objectType, id)" Value="@result">
                                    <AvatarContent>
                                        <MudIcon Icon="@Icons.Material.Filled.CheckCircleOutline" />
                                    </AvatarContent>
                                    <ChildContent>
                                        @result.TestName
                                    </ChildContent>
                                </MudListItem>
                            }
                        }
                    </ChildContent>
                </MudExpansionPanel>
            }
        </MudList>
    </MudExpansionPanels>

    @* <div class="p-2 flex flex-col w-full items-center">
        <MudText>This model has @(this.TestResults.Count - numFilteredTests) other tests.</MudText>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ToggleFilter">
            @(this.TestSelectorState.Value.EditorFilterApplied ? "Remove Filter" : "Hide Elements Without Tests")
        </MudButton>
    </div> *@
</div>


@code {
    [Parameter]
    public required string CanvasId { get; init; }

    [Parameter]
    public SelectedObject[]? SelectedObjects { get; init; }

    private BeamOsObjectType? SelectedObjectType => StringToEnum(this.SelectedObjects?.SingleOrDefault()?.TypeName);

    private string? SelectedObjectId => this.SelectedObjects?.SingleOrDefault()?.Id.ToString();

    private void SelectedTestInfoChanged(TestResult result)
    {
        this.Dispatcher.Dispatch(new TestResultSelected(result));
    }

    private void MouseOver(BeamOsObjectType objectType, string id)
    {
        if (!int.TryParse(id, out var intId))
        {
            return;
        }

        // this.Dispatcher.Dispatch(new ChangeSelectionCommand(this.CanvasId, [new SelectedObject(intId, EnumToString(objectType))]));
    }

    // protected override void OnInitialized()
    // {
    //     base.OnInitialized();
    //     this.SubscribeToAction<ChangeSelectionCommand>(command =>
    //     {
    //         if (command.CanvasId != this.CanvasId)
    //         {
    //             return;
    //         }

    //         if (command.SelectedObjects.Length != 1)
    //         {
    //             this.SelectedObjectId = null;
    //             this.SelectedObjectType = null;
    //         }

    //         this.SelectedObjectType = StringToEnum(command.SelectedObjects[0].TypeName);
    //         this.SelectedObjectId = command.SelectedObjects[0].Id.ToString();
    //     });
    // }

    [Parameter]
    public required IDictionary<BeamOsObjectType, ImmutableDictionary<string, List<TestResult>>> TestResults { get; init; }

    public BeamOsObjectType? StringToEnum(string? objectType)
    {
        return objectType switch
        {
            null => null,
            "Node" => BeamOsObjectType.Node,
            "Element1d" => BeamOsObjectType.Element1d,
            "Material" => BeamOsObjectType.Material,
            "SectionProfile" => BeamOsObjectType.SectionProfile,
            "PointLoad" => BeamOsObjectType.PointLoad,
            "MomentLoad" => BeamOsObjectType.MomentLoad,
            _ => throw new NotImplementedException($"Object type {objectType} is not implemented")
        };
    }

    public string EnumToString(BeamOsObjectType objectType)
    {
        return objectType switch
        {
            BeamOsObjectType.Node => "Node",
            BeamOsObjectType.Element1d => "Element1d",
            BeamOsObjectType.Material => "Material",
            BeamOsObjectType.SectionProfile => "SectionProfile",
            BeamOsObjectType.PointLoad => "PointLoad",
            BeamOsObjectType.MomentLoad => "MomentLoad",
            _ => throw new NotImplementedException($"Object type {objectType} is not implemented")
        };
    }

    // [Parameter]
    // public string ModelId { get; init; }

    // [Parameter]
    // public string CanvasId { get; init; }

    // [Inject]
    // private IState<TestSelectorState> TestSelectorState { get; init; }

    [Inject]
    private IDispatcher Dispatcher { get; init; }

    // [Inject]
    // private TestInfoProvider TestInfoProvider { get; init; }

    // [Inject]
    // private IServiceProvider ServiceProvider { get; init; }

    // [Inject]
    // private AllStructuralAnalysisModelCaches AllStructuralAnalysisModelCaches { get; init; }

    // private void OnSelectedTestInfoChanged(TestResult2 testResult)
    // {
    //     this.Dispatcher.Dispatch(new ChangeSelectedTestInfoAction(testInfo));
    //     await this.HandleExecuteTestAction(testInfo.Id);
    //     this.Dispatcher.Dispatch(new ExecutionTestActionResult("", testResult));
    // }

    // private async Task OnSelectedTestInfoChanged(TestInfo? testInfo)
    // {
    //     this.Dispatcher.Dispatch(new ChangeSelectedTestInfoAction(testInfo));
    //     await this.HandleExecuteTestAction(testInfo.Id);
    // }

    // private async Task HandleExecuteTestAction(string testId)
    // {
    //     TestInfo testInfo = this.TestInfoProvider.TestInfos[testId];

    //     todo : get and add to cache
    //     TestResult result = await testInfo.RunTest(this.ServiceProvider);
    //     this.Dispatcher.Dispatch(new ExecutionTestActionResult(testId, result));
    // }

    // private bool filterApplied;

    // private void ToggleFilter()
    // {
    //     if (this.TestSelectorState.Value.EditorFilterApplied)
    //     {
    //         this.RemoveFilters();
    //         this.Dispatcher.Dispatch(new ChangeEditorFilterApplied(false));
    //     }
    //     else
    //     {
    //         this.GhostObjectsWithoutTests();
    //         this.Dispatcher.Dispatch(new ChangeEditorFilterApplied(true));
    //     }
    // }

    private void GoBack()
    {
        this.Dispatcher.Dispatch(new ChangeSelectedProblemTests(null));
    }

    // private void GhostObjectsWithoutTests()
    // {
    //     var testIds = this.TestSelectorState.Value.AllTestResults.SelectMany(kvp => kvp.Value.Select(r => r.BeamOsObjectId)).ToList();

    //     this.Dispatcher.Dispatch(new SetColorFilterCommand(this.TestSelectorState.Value.CanvasId, new(testIds, true, "0x808080", true)));

    //     var idsToGhost = this.AllStructuralAnalysisModelCaches.GetByModelId(modelId).GetEntityIdsOfType<BeamOsEntityContractBase>();
    //     foreach (var id in this.TestSelectorState.Value.AllTestResults.SelectMany(kvp => kvp.Value.Select(r => r.BeamOsObjectId)))
    //     {
    //         idsToGhost.Remove(id);
    //     }

    // }

    // private void RemoveFilters()
    // {
    //     var testIds = this.TestSelectorState.Value.AllTestResults.SelectMany(kvp => kvp.Value.Select(r => r.BeamOsObjectId)).ToList();

    //     this.Dispatcher.Dispatch(new RemoveColorFilterCommand(this.TestSelectorState.Value.CanvasId, new(testIds, true)));
    // }
}
