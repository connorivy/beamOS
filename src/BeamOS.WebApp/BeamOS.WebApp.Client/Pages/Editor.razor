@page "/editor"
@using BeamOS.DirectStiffnessMethod.Client
@using BeamOS.DirectStiffnessMethod.Contracts.Model
@using BeamOS.PhysicalModel.Client
@using BeamOS.PhysicalModel.Contracts.Element1D
@using BeamOS.PhysicalModel.Contracts.Model
@using BeamOS.PhysicalModel.Contracts.Node
@using BeamOS.WebApp.EditorApi

@rendermode InteractiveAuto

@inject IJSRuntime js
@inject IPhysicalModelAlphaClient apiClient
@inject IDirectStiffnessMethodAlphaClient dsmClient
@inject EditorApiProxyFactory editorApiAlphaFactory

<PageTitle>Editor</PageTitle>

<div class="relative w-full h-3/4">
    <canvas id="@elementId" class="w-full h-full absolute"></canvas>
    @if (isLoading)
    {   
        <div class="bg-gray-800 w-full h-full absolute justify-center items-center opacity-80">
            <div class="flex w-full h-full m-auto left-0 right-0 top-0 bottom-0 justify-center items-center">
                <div class="rounded animate-spin ease duration-300 w-10 h-10 border-4 border-white"></div>
                <h2 class="px-3 font-bold text-white"> @loadingText ...</h2>
            </div>
        </div>
    }
</div>

<div style="width:100%; padding-bottom: 10px;">
    <button @onclick="Solve">
        Solve
    </button>
</div>

<style>
    table,
    th,
    td {
        border: 1px solid black;
        border-collapse: collapse;
    }
</style>

<table style="width:50%; float:left; border-width: 1px; margin-bottom: 20px;">
    <thead>
        <tr>
            <th>Calculated Reactions</th>
            <th>Expected Reactions</th>
            <th>Difference</th>
        </tr>
    </thead>
    @for (int i = 0; i < @ExpectedReactions.Count; i++)
    {
        <tr>
        @if (CalculatedReactions?.ElementAt(i) is double reaction)
        {
            <td>@reaction</td>
        }
        else
        {
            <td></td>;
        }
        <td>@ExpectedReactions[i]</td>
        @if (@GetDifferenceOrNull(@ExpectedReactions[i], @CalculatedReactions?.ElementAt(i)) is double diff)
        {
            <td>@diff</td>
        }
        else
        {
            <td>N/A</td>
        }
        </tr>
    }
</table>
<table style="width:50%; float:left;">
    <thead>
        <tr>
            <th>Calculated Displacements</th>
            <th>Expected Displacements</th>
            <th>Difference</th>
        </tr>
    </thead>
    @for (int i = 0; i < @ExpectedDisplacements.Count; i++)
    {
        <tr>
            @if (CalculatedDisplacements?.ElementAt(i) is double reaction)
            {
                <td>@reaction</td>
            }
            else
            {
                <td></td>
            }
            <td>@ExpectedDisplacements[i]</td>
            @if (@GetDifferenceOrNull(@ExpectedDisplacements[i], @CalculatedDisplacements?.ElementAt(i)) is double diff)
            {
                <td>@diff</td>
            }
            else
            {
                <td>N/A</td>
            }
        </tr>
    }
</table>

@code {
    private IEditorApiAlpha? editorApiAlpha;

    private string loadingText = "Loading beamOS Editor";
    private bool isLoading = true;

    string elementId = "id" + Guid.NewGuid().ToString("N");

    const string physicalModelId = "00000000-0000-0000-0000-000000000000";

    public List<double>? CalculatedReactions { get; set; }
    public List<double>? CalculatedDisplacements { get; set; }
    public List<double> ExpectedReactions { get; } = [
        0,
    0,
    0,
    -10.064,
    -13.419,
    0,
    0,
    0,
    0,
    126.83,
    0,
    0,
    0,
    -139.94,
    186.58,
    0,
    0,
    0,
    ];

    public List<double> ExpectedDisplacements { get; } = [
        .21552,
    -.13995,
    0,
    0,
    0,
    0
    ];

    private double? GetDifferenceOrNull(double expected, double? calculated)
    {
        if (calculated is null)
        {
            return null;
        }
        return expected - calculated;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            isLoading = true;
            editorApiAlpha ??= await editorApiAlphaFactory.Create(elementId);
            loadingText = "Fetching Data";
            StateHasChanged();
            await LoadModel();
            isLoading = false;
            StateHasChanged();
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task AddNode()
    {
        CreateNodeRequest request = new(
            physicalModelId,
            10,
            5,
            10,
            "Foot");

        NodeResponse response = await apiClient.CreateNodeAsync(request);
        var x = await editorApiAlpha.CreateNodeAsync(response);
    }

    private async Task LoadModel()
    {
        try
        {
            ModelResponseHydrated response = await apiClient.GetModelHydratedAsync(physicalModelId);
            var x = await editorApiAlpha.CreateModelHydratedAsync(response);
        }
        catch
        {
            
        }
    }

    private async Task Solve()
    {
        AnalyticalModelResponse response = await dsmClient.RunDirectStiffnessMethodAsync(physicalModelId);
        CalculatedReactions = response.AnalyticalNodeReactions;
        CalculatedDisplacements = response.AnalyticalNodeDisplacements;
    }
}

