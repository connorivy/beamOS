//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IStructuralAnalysisApiClientV1 {

    /**
     * @return OK
     */
    clearResults(modelId: string): Promise<number>;

    /**
     * @param unitsOverride (optional) 
     * @return OK
     */
    getDiagrams(modelId: string, id: number, unitsOverride: string | undefined): Promise<AnalyticalResultsResponse>;

    /**
     * @return OK
     */
    getResultSet(id: number, modelId: string): Promise<ResultSetResponse>;

    /**
     * @return OK
     */
    getNodeResult(modelId: string, loadCombinationId: number, id: number): Promise<NodeResultResponse>;

    /**
     * @return OK
     */
    getNodeResults(modelId: string, loadCombinationId: number): Promise<{ [key: string]: NodeResultResponse; }>;

    /**
     * @param body (optional) 
     * @return OK
     */
    runDirectStiffnessMethod(modelId: string, body: RunDsmRequest | null | undefined): Promise<AnalyticalResultsResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    runOpenSeesAnalysis(modelId: string, body: RunDsmRequest | null | undefined): Promise<AnalyticalResultsResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createElement1d(modelId: string, body: CreateElement1dRequest | null | undefined): Promise<Element1dResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutElement1d(modelId: string, body: PutElement1dRequest[] | null | undefined): Promise<BatchResponse>;

    /**
     * @return OK
     */
    deleteElement1d(id: number, modelId: string): Promise<ModelEntityResponse>;

    /**
     * @return OK
     */
    getElement1d(id: number, modelId: string): Promise<Element1dResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    putElement1d(modelId: string, id: number, body: Element1dData | null | undefined): Promise<Element1dResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutLoadCase(modelId: string, body: LoadCase[] | null | undefined): Promise<BatchResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createLoadCase(modelId: string, body: LoadCaseData | null | undefined): Promise<LoadCase>;

    /**
     * @return OK
     */
    deleteLoadCase(id: number, modelId: string): Promise<ModelEntityResponse>;

    /**
     * @return OK
     */
    getLoadCase(id: number, modelId: string): Promise<LoadCase>;

    /**
     * @param body (optional) 
     * @return OK
     */
    putLoadCase(modelId: string, id: number, body: LoadCaseData | null | undefined): Promise<LoadCase>;

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutLoadCombination(modelId: string, body: LoadCombination[] | null | undefined): Promise<BatchResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createLoadCombination(modelId: string, body: LoadCombinationData | null | undefined): Promise<LoadCombination>;

    /**
     * @return OK
     */
    deleteLoadCombination(id: number, modelId: string): Promise<ModelEntityResponse>;

    /**
     * @return OK
     */
    getLoadCombination(id: number, modelId: string): Promise<LoadCombination>;

    /**
     * @param body (optional) 
     * @return OK
     */
    putLoadCombination(modelId: string, id: number, body: LoadCombinationData | null | undefined): Promise<LoadCombination>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createMaterial(modelId: string, body: CreateMaterialRequest | null | undefined): Promise<MaterialResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutMaterial(modelId: string, body: PutMaterialRequest[] | null | undefined): Promise<BatchResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    putMaterial(modelId: string, id: number, body: MaterialData | null | undefined): Promise<MaterialResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createModel(body: CreateModelRequest | undefined): Promise<ModelResponse>;

    /**
     * @return OK
     */
    getModels(): Promise<ModelInfoResponse[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createModelProposal(modelId: string, body: ModelProposalData | null | undefined): Promise<ModelProposalResponse>;

    /**
     * @return OK
     */
    getModelProposals(modelId: string): Promise<ModelProposalInfo2[]>;

    /**
     * @return OK
     */
    getModelProposal(id: number, modelId: string): Promise<ModelProposalResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    acceptModelProposal(modelId: string, id: number, body: EntityProposal[] | null | undefined): Promise<ModelResponse>;

    /**
     * @return OK
     */
    rejectModelProposal(id: number, modelId: string): Promise<boolean>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createTempModel(body: CreateModelRequest | undefined): Promise<ModelResponse>;

    /**
     * @return OK
     */
    deleteModel(modelId: string): Promise<boolean>;

    /**
     * @return OK
     */
    getModel(modelId: string): Promise<ModelResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    putModel(modelId: string, body: ModelInfoData | null | undefined): Promise<ModelResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    repairModel(modelId: string, body: string | null | undefined): Promise<ModelProposalResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createMomentLoad(modelId: string, body: CreateMomentLoadRequest | null | undefined): Promise<MomentLoadResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutMomentLoad(modelId: string, body: PutMomentLoadRequest[] | null | undefined): Promise<BatchResponse>;

    /**
     * @return OK
     */
    deleteMomentLoad(id: number, modelId: string): Promise<ModelEntityResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    putMomentLoad(modelId: string, id: number, body: MomentLoadData | null | undefined): Promise<MomentLoadResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createNode(modelId: string, body: CreateNodeRequest2 | null | undefined): Promise<NodeResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    patchNode(modelId: string, body: UpdateNodeRequest | null | undefined): Promise<NodeResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutNode(modelId: string, body: PutNodeRequest[] | null | undefined): Promise<BatchResponse>;

    /**
     * @return OK
     */
    getInternalNode(id: number, modelId: string): Promise<InternalNode>;

    /**
     * @param body (optional) 
     * @return OK
     */
    putInternalNode(modelId: string, id: number, body: InternalNodeData | null | undefined): Promise<InternalNode>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createInternalNode(modelId: string, body: CreateInternalNodeRequest | null | undefined): Promise<InternalNode>;

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutInternalNode(modelId: string, body: InternalNode[] | null | undefined): Promise<BatchResponse>;

    /**
     * @return OK
     */
    deleteNode(id: number, modelId: string): Promise<ModelEntityResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    putNode(modelId: string, id: number, body: NodeData | null | undefined): Promise<NodeResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createPointLoad(modelId: string, body: CreatePointLoadRequest | null | undefined): Promise<PointLoadResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutPointLoad(modelId: string, body: PutPointLoadRequest[] | null | undefined): Promise<BatchResponse>;

    /**
     * @return OK
     */
    deletePointLoad(id: number, modelId: string): Promise<ModelEntityResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    putPointLoad(modelId: string, id: number, body: PointLoadData | null | undefined): Promise<PointLoadResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    addSectionProfileFromLibrary(modelId: string, body: SectionProfileFromLibraryData | null | undefined): Promise<SectionProfileResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutSectionProfileFromLibrary(modelId: string, body: SectionProfileFromLibrary[] | null | undefined): Promise<BatchResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    createSectionProfile(modelId: string, body: CreateSectionProfileRequest2 | null | undefined): Promise<SectionProfileResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutSectionProfile(modelId: string, body: PutSectionProfileRequest[] | null | undefined): Promise<BatchResponse>;

    /**
     * @return OK
     */
    deleteSectionProfile(id: number, modelId: string): Promise<ModelEntityResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    putSectionProfile(modelId: string, id: number, body: SectionProfileData | null | undefined): Promise<SectionProfileResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    putSectionProfileFromLibrary(modelId: string, id: number, body: SectionProfileFromLibraryData | null | undefined): Promise<SectionProfileFromLibrary>;

    /**
     * @return OK
     */
    modelRestore(modelId: string, body: Date): Promise<ModelResponse>;
}

export class StructuralAnalysisApiClientV1 implements IStructuralAnalysisApiClientV1 {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5079/";
    }

    /**
     * @return OK
     */
    clearResults(modelId: string): Promise<number> {
        let url_ = this.baseUrl + "/api/models/{modelId}/results";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearResults(_response);
        });
    }

    protected processClearResults(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param unitsOverride (optional) 
     * @return OK
     */
    getDiagrams(modelId: string, id: number, unitsOverride: string | undefined): Promise<AnalyticalResultsResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/result-sets/{id}/diagrams?";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (unitsOverride === null)
            throw new Error("The parameter 'unitsOverride' cannot be null.");
        else if (unitsOverride !== undefined)
            url_ += "UnitsOverride=" + encodeURIComponent("" + unitsOverride) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDiagrams(_response);
        });
    }

    protected processGetDiagrams(response: Response): Promise<AnalyticalResultsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AnalyticalResultsResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalyticalResultsResponse>(null as any);
    }

    /**
     * @return OK
     */
    getResultSet(id: number, modelId: string): Promise<ResultSetResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/result-sets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetResultSet(_response);
        });
    }

    protected processGetResultSet(response: Response): Promise<ResultSetResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResultSetResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultSetResponse>(null as any);
    }

    /**
     * @return OK
     */
    getNodeResult(modelId: string, loadCombinationId: number, id: number): Promise<NodeResultResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/results/load-combinations/{loadCombinationId}/nodes/{id}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (loadCombinationId === undefined || loadCombinationId === null)
            throw new Error("The parameter 'loadCombinationId' must be defined.");
        url_ = url_.replace("{loadCombinationId}", encodeURIComponent("" + loadCombinationId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNodeResult(_response);
        });
    }

    protected processGetNodeResult(response: Response): Promise<NodeResultResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NodeResultResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NodeResultResponse>(null as any);
    }

    /**
     * @return OK
     */
    getNodeResults(modelId: string, loadCombinationId: number): Promise<{ [key: string]: NodeResultResponse; }> {
        let url_ = this.baseUrl + "/api/models/{modelId}/results/load-combinations/{loadCombinationId}/nodes";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (loadCombinationId === undefined || loadCombinationId === null)
            throw new Error("The parameter 'loadCombinationId' must be defined.");
        url_ = url_.replace("{loadCombinationId}", encodeURIComponent("" + loadCombinationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNodeResults(_response);
        });
    }

    protected processGetNodeResults(response: Response): Promise<{ [key: string]: NodeResultResponse; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: NodeResultResponse; };
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: NodeResultResponse; }>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    runDirectStiffnessMethod(modelId: string, body: RunDsmRequest | null | undefined): Promise<AnalyticalResultsResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/analyze/dsm";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRunDirectStiffnessMethod(_response);
        });
    }

    protected processRunDirectStiffnessMethod(response: Response): Promise<AnalyticalResultsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AnalyticalResultsResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalyticalResultsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    runOpenSeesAnalysis(modelId: string, body: RunDsmRequest | null | undefined): Promise<AnalyticalResultsResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/analyze/opensees";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRunOpenSeesAnalysis(_response);
        });
    }

    protected processRunOpenSeesAnalysis(response: Response): Promise<AnalyticalResultsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AnalyticalResultsResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AnalyticalResultsResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createElement1d(modelId: string, body: CreateElement1dRequest | null | undefined): Promise<Element1dResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/element1ds";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateElement1d(_response);
        });
    }

    protected processCreateElement1d(response: Response): Promise<Element1dResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Element1dResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Element1dResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutElement1d(modelId: string, body: PutElement1dRequest[] | null | undefined): Promise<BatchResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/element1ds";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchPutElement1d(_response);
        });
    }

    protected processBatchPutElement1d(response: Response): Promise<BatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatchResponse>(null as any);
    }

    /**
     * @return OK
     */
    deleteElement1d(id: number, modelId: string): Promise<ModelEntityResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/element1ds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteElement1d(_response);
        });
    }

    protected processDeleteElement1d(response: Response): Promise<ModelEntityResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelEntityResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelEntityResponse>(null as any);
    }

    /**
     * @return OK
     */
    getElement1d(id: number, modelId: string): Promise<Element1dResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/element1ds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetElement1d(_response);
        });
    }

    protected processGetElement1d(response: Response): Promise<Element1dResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Element1dResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Element1dResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putElement1d(modelId: string, id: number, body: Element1dData | null | undefined): Promise<Element1dResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/element1ds/{id}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutElement1d(_response);
        });
    }

    protected processPutElement1d(response: Response): Promise<Element1dResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Element1dResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Element1dResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutLoadCase(modelId: string, body: LoadCase[] | null | undefined): Promise<BatchResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/load-cases";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchPutLoadCase(_response);
        });
    }

    protected processBatchPutLoadCase(response: Response): Promise<BatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatchResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createLoadCase(modelId: string, body: LoadCaseData | null | undefined): Promise<LoadCase> {
        let url_ = this.baseUrl + "/api/models/{modelId}/load-cases";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLoadCase(_response);
        });
    }

    protected processCreateLoadCase(response: Response): Promise<LoadCase> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadCase;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoadCase>(null as any);
    }

    /**
     * @return OK
     */
    deleteLoadCase(id: number, modelId: string): Promise<ModelEntityResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/load-cases/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteLoadCase(_response);
        });
    }

    protected processDeleteLoadCase(response: Response): Promise<ModelEntityResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelEntityResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelEntityResponse>(null as any);
    }

    /**
     * @return OK
     */
    getLoadCase(id: number, modelId: string): Promise<LoadCase> {
        let url_ = this.baseUrl + "/api/models/{modelId}/load-cases/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLoadCase(_response);
        });
    }

    protected processGetLoadCase(response: Response): Promise<LoadCase> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadCase;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoadCase>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putLoadCase(modelId: string, id: number, body: LoadCaseData | null | undefined): Promise<LoadCase> {
        let url_ = this.baseUrl + "/api/models/{modelId}/load-cases/{id}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutLoadCase(_response);
        });
    }

    protected processPutLoadCase(response: Response): Promise<LoadCase> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadCase;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoadCase>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutLoadCombination(modelId: string, body: LoadCombination[] | null | undefined): Promise<BatchResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/load-combinations";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchPutLoadCombination(_response);
        });
    }

    protected processBatchPutLoadCombination(response: Response): Promise<BatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatchResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createLoadCombination(modelId: string, body: LoadCombinationData | null | undefined): Promise<LoadCombination> {
        let url_ = this.baseUrl + "/api/models/{modelId}/load-combinations";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLoadCombination(_response);
        });
    }

    protected processCreateLoadCombination(response: Response): Promise<LoadCombination> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadCombination;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoadCombination>(null as any);
    }

    /**
     * @return OK
     */
    deleteLoadCombination(id: number, modelId: string): Promise<ModelEntityResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/load-combinations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteLoadCombination(_response);
        });
    }

    protected processDeleteLoadCombination(response: Response): Promise<ModelEntityResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelEntityResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelEntityResponse>(null as any);
    }

    /**
     * @return OK
     */
    getLoadCombination(id: number, modelId: string): Promise<LoadCombination> {
        let url_ = this.baseUrl + "/api/models/{modelId}/load-combinations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLoadCombination(_response);
        });
    }

    protected processGetLoadCombination(response: Response): Promise<LoadCombination> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadCombination;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoadCombination>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putLoadCombination(modelId: string, id: number, body: LoadCombinationData | null | undefined): Promise<LoadCombination> {
        let url_ = this.baseUrl + "/api/models/{modelId}/load-combinations/{id}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutLoadCombination(_response);
        });
    }

    protected processPutLoadCombination(response: Response): Promise<LoadCombination> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoadCombination;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoadCombination>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMaterial(modelId: string, body: CreateMaterialRequest | null | undefined): Promise<MaterialResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/materials";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMaterial(_response);
        });
    }

    protected processCreateMaterial(response: Response): Promise<MaterialResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MaterialResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MaterialResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutMaterial(modelId: string, body: PutMaterialRequest[] | null | undefined): Promise<BatchResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/materials";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchPutMaterial(_response);
        });
    }

    protected processBatchPutMaterial(response: Response): Promise<BatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatchResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putMaterial(modelId: string, id: number, body: MaterialData | null | undefined): Promise<MaterialResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/materials/{id}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutMaterial(_response);
        });
    }

    protected processPutMaterial(response: Response): Promise<MaterialResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MaterialResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MaterialResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createModel(body: CreateModelRequest | undefined): Promise<ModelResponse> {
        let url_ = this.baseUrl + "/api/models";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateModel(_response);
        });
    }

    protected processCreateModel(response: Response): Promise<ModelResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelResponse>(null as any);
    }

    /**
     * @return OK
     */
    getModels(): Promise<ModelInfoResponse[]> {
        let url_ = this.baseUrl + "/api/models";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModels(_response);
        });
    }

    protected processGetModels(response: Response): Promise<ModelInfoResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelInfoResponse[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelInfoResponse[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createModelProposal(modelId: string, body: ModelProposalData | null | undefined): Promise<ModelProposalResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/proposals";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateModelProposal(_response);
        });
    }

    protected processCreateModelProposal(response: Response): Promise<ModelProposalResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelProposalResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelProposalResponse>(null as any);
    }

    /**
     * @return OK
     */
    getModelProposals(modelId: string): Promise<ModelProposalInfo2[]> {
        let url_ = this.baseUrl + "/api/models/{modelId}/proposals";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModelProposals(_response);
        });
    }

    protected processGetModelProposals(response: Response): Promise<ModelProposalInfo2[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelProposalInfo2[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelProposalInfo2[]>(null as any);
    }

    /**
     * @return OK
     */
    getModelProposal(id: number, modelId: string): Promise<ModelProposalResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/proposals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModelProposal(_response);
        });
    }

    protected processGetModelProposal(response: Response): Promise<ModelProposalResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelProposalResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelProposalResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    acceptModelProposal(modelId: string, id: number, body: EntityProposal[] | null | undefined): Promise<ModelResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/proposals/{id}/accept";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcceptModelProposal(_response);
        });
    }

    protected processAcceptModelProposal(response: Response): Promise<ModelResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelResponse>(null as any);
    }

    /**
     * @return OK
     */
    rejectModelProposal(id: number, modelId: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/models/{modelId}/proposals/{id}/reject";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRejectModelProposal(_response);
        });
    }

    protected processRejectModelProposal(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createTempModel(body: CreateModelRequest | undefined): Promise<ModelResponse> {
        let url_ = this.baseUrl + "/api/models/temp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTempModel(_response);
        });
    }

    protected processCreateTempModel(response: Response): Promise<ModelResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelResponse>(null as any);
    }

    /**
     * @return OK
     */
    deleteModel(modelId: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/models/{modelId}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteModel(_response);
        });
    }

    protected processDeleteModel(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return OK
     */
    getModel(modelId: string): Promise<ModelResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModel(_response);
        });
    }

    protected processGetModel(response: Response): Promise<ModelResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putModel(modelId: string, body: ModelInfoData | null | undefined): Promise<ModelResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutModel(_response);
        });
    }

    protected processPutModel(response: Response): Promise<ModelResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    repairModel(modelId: string, body: string | null | undefined): Promise<ModelProposalResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/repair";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepairModel(_response);
        });
    }

    protected processRepairModel(response: Response): Promise<ModelProposalResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelProposalResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelProposalResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMomentLoad(modelId: string, body: CreateMomentLoadRequest | null | undefined): Promise<MomentLoadResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/moment-loads";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMomentLoad(_response);
        });
    }

    protected processCreateMomentLoad(response: Response): Promise<MomentLoadResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MomentLoadResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MomentLoadResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutMomentLoad(modelId: string, body: PutMomentLoadRequest[] | null | undefined): Promise<BatchResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/moment-loads";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchPutMomentLoad(_response);
        });
    }

    protected processBatchPutMomentLoad(response: Response): Promise<BatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatchResponse>(null as any);
    }

    /**
     * @return OK
     */
    deleteMomentLoad(id: number, modelId: string): Promise<ModelEntityResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/moment-loads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMomentLoad(_response);
        });
    }

    protected processDeleteMomentLoad(response: Response): Promise<ModelEntityResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelEntityResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelEntityResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putMomentLoad(modelId: string, id: number, body: MomentLoadData | null | undefined): Promise<MomentLoadResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/moment-loads/{id}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutMomentLoad(_response);
        });
    }

    protected processPutMomentLoad(response: Response): Promise<MomentLoadResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MomentLoadResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MomentLoadResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createNode(modelId: string, body: CreateNodeRequest2 | null | undefined): Promise<NodeResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/nodes";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateNode(_response);
        });
    }

    protected processCreateNode(response: Response): Promise<NodeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NodeResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NodeResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    patchNode(modelId: string, body: UpdateNodeRequest | null | undefined): Promise<NodeResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/nodes";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPatchNode(_response);
        });
    }

    protected processPatchNode(response: Response): Promise<NodeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NodeResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NodeResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutNode(modelId: string, body: PutNodeRequest[] | null | undefined): Promise<BatchResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/nodes";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchPutNode(_response);
        });
    }

    protected processBatchPutNode(response: Response): Promise<BatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatchResponse>(null as any);
    }

    /**
     * @return OK
     */
    getInternalNode(id: number, modelId: string): Promise<InternalNode> {
        let url_ = this.baseUrl + "/api/models/{modelId}/nodes/{id}/internal";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInternalNode(_response);
        });
    }

    protected processGetInternalNode(response: Response): Promise<InternalNode> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InternalNode;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InternalNode>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putInternalNode(modelId: string, id: number, body: InternalNodeData | null | undefined): Promise<InternalNode> {
        let url_ = this.baseUrl + "/api/models/{modelId}/nodes/{id}/internal";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutInternalNode(_response);
        });
    }

    protected processPutInternalNode(response: Response): Promise<InternalNode> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InternalNode;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InternalNode>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createInternalNode(modelId: string, body: CreateInternalNodeRequest | null | undefined): Promise<InternalNode> {
        let url_ = this.baseUrl + "/api/models/{modelId}/nodes/internal";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateInternalNode(_response);
        });
    }

    protected processCreateInternalNode(response: Response): Promise<InternalNode> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InternalNode;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InternalNode>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutInternalNode(modelId: string, body: InternalNode[] | null | undefined): Promise<BatchResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/nodes/internal";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchPutInternalNode(_response);
        });
    }

    protected processBatchPutInternalNode(response: Response): Promise<BatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatchResponse>(null as any);
    }

    /**
     * @return OK
     */
    deleteNode(id: number, modelId: string): Promise<ModelEntityResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/nodes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteNode(_response);
        });
    }

    protected processDeleteNode(response: Response): Promise<ModelEntityResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelEntityResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelEntityResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putNode(modelId: string, id: number, body: NodeData | null | undefined): Promise<NodeResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/nodes/{id}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutNode(_response);
        });
    }

    protected processPutNode(response: Response): Promise<NodeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NodeResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NodeResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createPointLoad(modelId: string, body: CreatePointLoadRequest | null | undefined): Promise<PointLoadResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/point-loads";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePointLoad(_response);
        });
    }

    protected processCreatePointLoad(response: Response): Promise<PointLoadResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PointLoadResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PointLoadResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutPointLoad(modelId: string, body: PutPointLoadRequest[] | null | undefined): Promise<BatchResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/point-loads";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchPutPointLoad(_response);
        });
    }

    protected processBatchPutPointLoad(response: Response): Promise<BatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatchResponse>(null as any);
    }

    /**
     * @return OK
     */
    deletePointLoad(id: number, modelId: string): Promise<ModelEntityResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/point-loads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePointLoad(_response);
        });
    }

    protected processDeletePointLoad(response: Response): Promise<ModelEntityResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelEntityResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelEntityResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putPointLoad(modelId: string, id: number, body: PointLoadData | null | undefined): Promise<PointLoadResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/point-loads/{id}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutPointLoad(_response);
        });
    }

    protected processPutPointLoad(response: Response): Promise<PointLoadResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PointLoadResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PointLoadResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addSectionProfileFromLibrary(modelId: string, body: SectionProfileFromLibraryData | null | undefined): Promise<SectionProfileResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/section-profiles/from-library";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddSectionProfileFromLibrary(_response);
        });
    }

    protected processAddSectionProfileFromLibrary(response: Response): Promise<SectionProfileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SectionProfileResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SectionProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutSectionProfileFromLibrary(modelId: string, body: SectionProfileFromLibrary[] | null | undefined): Promise<BatchResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/section-profiles/from-library";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchPutSectionProfileFromLibrary(_response);
        });
    }

    protected processBatchPutSectionProfileFromLibrary(response: Response): Promise<BatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatchResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createSectionProfile(modelId: string, body: CreateSectionProfileRequest2 | null | undefined): Promise<SectionProfileResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/section-profiles";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSectionProfile(_response);
        });
    }

    protected processCreateSectionProfile(response: Response): Promise<SectionProfileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SectionProfileResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SectionProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    batchPutSectionProfile(modelId: string, body: PutSectionProfileRequest[] | null | undefined): Promise<BatchResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/section-profiles";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchPutSectionProfile(_response);
        });
    }

    protected processBatchPutSectionProfile(response: Response): Promise<BatchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BatchResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BatchResponse>(null as any);
    }

    /**
     * @return OK
     */
    deleteSectionProfile(id: number, modelId: string): Promise<ModelEntityResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/section-profiles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSectionProfile(_response);
        });
    }

    protected processDeleteSectionProfile(response: Response): Promise<ModelEntityResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelEntityResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelEntityResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putSectionProfile(modelId: string, id: number, body: SectionProfileData | null | undefined): Promise<SectionProfileResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/section-profiles/{id}";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutSectionProfile(_response);
        });
    }

    protected processPutSectionProfile(response: Response): Promise<SectionProfileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SectionProfileResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SectionProfileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    putSectionProfileFromLibrary(modelId: string, id: number, body: SectionProfileFromLibraryData | null | undefined): Promise<SectionProfileFromLibrary> {
        let url_ = this.baseUrl + "/api/models/{modelId}/section-profiles/{id}/from-library";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutSectionProfileFromLibrary(_response);
        });
    }

    protected processPutSectionProfileFromLibrary(response: Response): Promise<SectionProfileFromLibrary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SectionProfileFromLibrary;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SectionProfileFromLibrary>(null as any);
    }

    /**
     * @return OK
     */
    modelRestore(modelId: string, body: Date): Promise<ModelResponse> {
        let url_ = this.baseUrl + "/api/models/{modelId}/restore";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined.");
        url_ = url_.replace("{modelId}", encodeURIComponent("" + modelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModelRestore(_response);
        });
    }

    protected processModelRestore(response: Response): Promise<ModelResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModelResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelResponse>(null as any);
    }
}

export interface AnalysisSettings {
    element1DAnalysisType?: number;

    [key: string]: any;
}

export interface AnalyticalResultsResponse {
    shearDiagrams?: ShearDiagramResponse[];
    momentDiagrams?: MomentDiagramResponse[];
    deflectionDiagrams?: DeflectionDiagramResponse[];
    globalStresses?: GlobalStresses;
    id: number;
    modelId: string;

    [key: string]: any;
}

export interface Angle {
    value: number;
    unit: number;

    [key: string]: any;
}

export interface BatchResponse {
    created?: number;
    updated?: number;
    deleted?: number;
    errors?: number;
    entityStatuses?: EntityStatus[];

    [key: string]: any;
}

export interface CreateElement1dProposal {
    id?: number | undefined;
    startNodeId: ProposedID;
    endNodeId: ProposedID;
    materialId: ProposedID;
    sectionProfileId: ProposedID;
    sectionProfileRotation?: NullableOfAngle | undefined;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface CreateElement1dProposalResponse {
    id?: number;
    startNodeId: ProposedID;
    endNodeId: ProposedID;
    materialId: ProposedID;
    sectionProfileId: ProposedID;
    sectionProfileRotation?: NullableOfAngle | undefined;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface CreateElement1dRequest {
    startNodeId: number;
    endNodeId: number;
    materialId: number;
    sectionProfileId: number;
    sectionProfileRotation?: NullableOfAngle | undefined;
    id?: number | undefined;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface CreateInternalNodeProposalResponse {
    element1dId: ProposedID;
    ratioAlongElement1d: Ratio;
    restraint: Restraint;
    metadata?: { [key: string]: string; } | undefined;
    id?: number;

    [key: string]: any;
}

export interface CreateInternalNodeRequest {
    id?: number | undefined;
    element1dId: number;
    ratioAlongElement1d: Ratio;
    restraint: Restraint;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface CreateMaterialRequest {
    id?: number | undefined;
    modulusOfElasticity: number;
    modulusOfRigidity: number;
    pressureUnit: number;

    [key: string]: any;
}

export interface CreateMaterialRequest2 {
    id?: number | undefined;
    modulusOfElasticity: number;
    modulusOfRigidity: number;
    pressureUnit: number;

    [key: string]: any;
}

export interface CreateModelRequest {
    id?: string | undefined;
    name: string;
    description: string;
    settings: ModelSettings;

    [key: string]: any;
}

export interface CreateMomentLoadRequest {
    nodeId: number;
    loadCaseId: number;
    torque: Torque;
    axisDirection: Vector3;
    id?: number | undefined;

    [key: string]: any;
}

export interface CreateNodeProposalResponse {
    id: number;
    locationPoint: Point;
    restraint: Restraint;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface CreateNodeRequest {
    id?: number | undefined;
    locationPoint: Point;
    restraint: Restraint;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface CreateNodeRequest2 {
    id?: number | undefined;
    locationPoint: Point;
    restraint: Restraint;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface CreatePointLoadRequest {
    nodeId: number;
    loadCaseId: number;
    force: Force;
    direction: Vector3;
    id?: number | undefined;

    [key: string]: any;
}

export interface CreateSectionProfileFromLibraryRequest {
    id: number;
    library: number;
    name: string;

    [key: string]: any;
}

export interface CreateSectionProfileRequest {
    id?: number | undefined;
    area: number;
    strongAxisMomentOfInertia: number;
    weakAxisMomentOfInertia: number;
    polarMomentOfInertia: number;
    strongAxisPlasticSectionModulus: number;
    weakAxisPlasticSectionModulus: number;
    strongAxisShearArea?: number | undefined;
    weakAxisShearArea?: number | undefined;
    lengthUnit: number;
    name: string;

    [key: string]: any;
}

export interface CreateSectionProfileRequest2 {
    id?: number | undefined;
    area: number;
    strongAxisMomentOfInertia: number;
    weakAxisMomentOfInertia: number;
    polarMomentOfInertia: number;
    strongAxisPlasticSectionModulus: number;
    weakAxisPlasticSectionModulus: number;
    strongAxisShearArea?: number | undefined;
    weakAxisShearArea?: number | undefined;
    lengthUnit: number;
    name: string;

    [key: string]: any;
}

export interface DeflectionDiagramResponse {
    element1dId: number;
    numSteps: number;
    offsets: number[];

    [key: string]: any;
}

export interface DeleteModelEntityProposal {
    proposalType?: number;
    id: number;
    objectType: number;

    [key: string]: any;
}

export interface DeleteModelEntityProposalData {
    id: number;
    objectType: number;

    [key: string]: any;
}

export interface DiagramConsistentIntervalResponse {
    startLocation: Length;
    endLocation: Length;
    polynomialCoefficients: number[];

    [key: string]: any;
}

export interface DiagramConsistentIntervalResponse2 {
    startLocation: Length;
    endLocation: Length;
    polynomialCoefficients: number[];

    [key: string]: any;
}

export interface DisplacementsResponse {
    displacementAlongX: Length;
    displacementAlongY: Length;
    displacementAlongZ: Length;
    rotationAboutX: Angle;
    rotationAboutY: Angle;
    rotationAboutZ: Angle;

    [key: string]: any;
}

export interface Element1dData {
    startNodeId: number;
    endNodeId: number;
    materialId: number;
    sectionProfileId: number;
    sectionProfileRotation?: NullableOfAngle | undefined;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface Element1dResponse {
    id: number;
    modelId: string;
    startNodeId: number;
    endNodeId: number;
    materialId: number;
    sectionProfileId: number;
    sectionProfileRotation: Angle;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface Element1dResultResponse {
    modelId: string;
    resultSetId: number;
    element1dId: number;
    minShear: Length;
    maxShear: Length;
    minMoment: Torque;
    maxMoment: Torque;
    minDisplacement: Length;
    maxDisplacement: Length;

    [key: string]: any;
}

export interface EntityProposal {
    objectType: number;
    id: number;
    proposalType: number;

    [key: string]: any;
}

export interface EntityStatus {
    id: number;
    entityOperationStatus: number;
    errorMessage?: string;

    [key: string]: any;
}

export interface Force {
    value: number;
    unit: number;

    [key: string]: any;
}

export interface ForcesResponse {
    forceAlongX: Force;
    forceAlongY: Force;
    forceAlongZ: Force;
    momentAboutX: Torque;
    momentAboutY: Torque;
    momentAboutZ: Torque;

    [key: string]: any;
}

export interface GlobalStresses {
    maxShear: Force;
    minShear: Force;
    maxMoment: Torque;
    minMoment: Torque;

    [key: string]: any;
}

export interface InternalNode {
    id: number;
    element1dId: number;
    ratioAlongElement1d: Ratio;
    restraint: Restraint;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface InternalNodeData {
    element1dId: number;
    ratioAlongElement1d: Ratio;
    restraint: Restraint;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface Length {
    value: number;
    unit: number;

    [key: string]: any;
}

export interface LoadCase {
    id: number;
    name: string;

    [key: string]: any;
}

export interface LoadCaseData {
    name: string;

    [key: string]: any;
}

export interface LoadCombination {
    id: number;
    loadCaseFactors: { [key: string]: number; };

    [key: string]: any;
}

export interface LoadCombinationData {
    loadCaseFactors: { [key: string]: number; };

    [key: string]: any;
}

export interface MaterialData {
    modulusOfElasticity: number;
    modulusOfRigidity: number;
    pressureUnit: number;

    [key: string]: any;
}

export interface MaterialResponse {
    id: number;
    modelId: string;
    modulusOfElasticity: number;
    modulusOfRigidity: number;
    pressureUnit: number;

    [key: string]: any;
}

export interface ModelEntityResponse {
    id: number;
    modelId: string;

    [key: string]: any;
}

export interface ModelInfoData {
    name: string;
    description: string;
    settings: ModelSettings;

    [key: string]: any;
}

export interface ModelInfoResponse {
    id: string;
    name: string;
    description: string;
    settings: ModelSettings;
    lastModified: Date;
    role: string;

    [key: string]: any;
}

export interface ModelProposalData {
    name?: string | undefined;
    description?: string | undefined;
    settings?: ModelSettings2 | undefined;
    createNodeProposals?: CreateNodeRequest[] | undefined;
    modifyNodeProposals?: PutNodeRequest[] | undefined;
    createElement1dProposals?: CreateElement1dProposal[] | undefined;
    modifyElement1dProposals?: ModifyElement1dProposal[] | undefined;
    createMaterialProposals?: CreateMaterialRequest2[] | undefined;
    modifyMaterialProposals?: PutMaterialRequest[] | undefined;
    createSectionProfileProposals?: CreateSectionProfileRequest[] | undefined;
    modifySectionProfileProposals?: PutSectionProfileRequest[] | undefined;
    createSectionProfileFromLibraryProposals?: CreateSectionProfileFromLibraryRequest[] | undefined;
    pointLoadProposals?: PointLoad[] | undefined;
    momentLoadProposals?: MomentLoad[] | undefined;
    resultSetProposals?: ResultSet[] | undefined;
    loadCaseProposals?: LoadCase[] | undefined;
    loadCombinationProposals?: LoadCombination[] | undefined;
    proposalIssues?: ProposalIssueData[] | undefined;
    deleteModelEntityProposals?: DeleteModelEntityProposalData[] | undefined;

    [key: string]: any;
}

export interface ModelProposalInfo {
    id: number;
    lastModified: Date;
    description?: string | undefined;

    [key: string]: any;
}

export interface ModelProposalInfo2 {
    id: number;
    lastModified: Date;
    description?: string | undefined;

    [key: string]: any;
}

export interface ModelProposalResponse {
    id: number;
    lastModified: Date;
    modelProposal?: ModelProposalInfo | undefined;
    createNodeProposals?: CreateNodeProposalResponse[] | undefined;
    modifyNodeProposals?: ModifyNodeProposalResponse[] | undefined;
    createInternalNodeProposals?: CreateInternalNodeProposalResponse[] | undefined;
    modifyInternalNodeProposals?: ModifyInternalNodeProposalResponse[] | undefined;
    createElement1dProposals?: CreateElement1dProposalResponse[] | undefined;
    modifyElement1dProposals?: ModifyElement1dProposalResponse[] | undefined;
    element1dsModifiedBecauseOfNodeChange?: number[] | undefined;
    materialProposals?: PutMaterialRequest[] | undefined;
    sectionProfileProposals?: PutSectionProfileRequest[] | undefined;
    sectionProfileFromLibraryProposals?: SectionProfileFromLibrary[] | undefined;
    pointLoadProposals?: PointLoad[] | undefined;
    momentLoadProposals?: MomentLoad[] | undefined;
    resultSetProposals?: ResultSet[] | undefined;
    loadCaseProposals?: LoadCase[] | undefined;
    loadCombinationProposals?: LoadCombination[] | undefined;
    proposalIssues?: ProposalIssue[] | undefined;
    deleteModelEntityProposals?: DeleteModelEntityProposal[] | undefined;

    [key: string]: any;
}

export interface ModelResponse {
    id: string;
    name: string;
    description: string;
    settings: ModelSettings;
    lastModified: Date;
    nodes?: NodeResponse[] | undefined;
    internalNodes?: InternalNode[] | undefined;
    element1ds?: Element1dResponse[] | undefined;
    materials?: MaterialResponse[] | undefined;
    sectionProfiles?: SectionProfileResponse[] | undefined;
    sectionProfilesFromLibrary?: SectionProfileFromLibrary[] | undefined;
    pointLoads?: PointLoadResponse[] | undefined;
    momentLoads?: MomentLoadResponse[] | undefined;
    resultSets?: ResultSetResponse[] | undefined;
    loadCases?: LoadCase[] | undefined;
    loadCombinations?: LoadCombination[] | undefined;

    [key: string]: any;
}

export interface ModelSettings {
    unitSettings: UnitSettings;
    analysisSettings: AnalysisSettings;
    yAxisUp: boolean;

    [key: string]: any;
}

export interface ModelSettings2 {
    unitSettings: UnitSettings;
    analysisSettings: AnalysisSettings;
    yAxisUp: boolean;

    [key: string]: any;
}

export interface ModifyElement1dProposal {
    existingElement1dId: number;
    startNodeId?: ProposedID2 | undefined;
    endNodeId?: ProposedID2 | undefined;
    materialId?: ProposedID2 | undefined;
    sectionProfileId?: ProposedID2 | undefined;
    sectionProfileRotation?: NullableOfAngle | undefined;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface ModifyElement1dProposalResponse {
    id?: number;
    existingElement1dId: number;
    startNodeId: ProposedID;
    endNodeId: ProposedID;
    materialId: ProposedID;
    sectionProfileId: ProposedID;
    existingId?: number;
    objectType?: number;
    sectionProfileRotation?: NullableOfAngle | undefined;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface ModifyInternalNodeProposalResponse {
    id: number;
    element1dId: ProposedID;
    ratioAlongElement1d: Ratio;
    restraint?: NullableOfRestraint | undefined;
    existingInternalNodeId: number;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface ModifyNodeProposalResponse {
    existingNodeId: number;
    id: number;
    locationPoint: Point;
    restraint: Restraint;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface MomentDiagramResponse {
    modelId: string;
    resultSetId: number;
    element1dId: number;
    lengthUnit: number;
    torqueUnit: number;
    elementLength: Length;
    intervals: DiagramConsistentIntervalResponse2[];

    [key: string]: any;
}

export interface MomentLoad {
    id?: number;
    nodeId: number;
    loadCaseId: number;
    torque: Torque;
    axisDirection: Vector3;

    [key: string]: any;
}

export interface MomentLoadData {
    nodeId: number;
    loadCaseId: number;
    torque: Torque;
    axisDirection: Vector3;

    [key: string]: any;
}

export interface MomentLoadResponse {
    id: number;
    nodeId: number;
    loadCaseId: number;
    modelId: string;
    torque: Torque;
    axisDirection: Vector3;

    [key: string]: any;
}

export interface NodeData {
    locationPoint: Point;
    restraint: Restraint;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface NodeResponse {
    id: number;
    modelId: string;
    locationPoint: Point;
    restraint: Restraint;

    [key: string]: any;
}

export interface NodeResultResponse {
    modelId: string;
    resultSetId: number;
    nodeId: number;
    forces: ForcesResponse;
    displacements: DisplacementsResponse;

    [key: string]: any;
}

export interface NullableOfAngle {
    value: number;
    unit: number;

    [key: string]: any;
}

export interface NullableOfPartialPoint {
    x?: number | undefined;
    y?: number | undefined;
    z?: number | undefined;
    lengthUnit: number;

    [key: string]: any;
}

export interface NullableOfPartialRestraint {
    canTranslateAlongX?: boolean | undefined;
    canTranslateAlongY?: boolean | undefined;
    canTranslateAlongZ?: boolean | undefined;
    canRotateAboutX?: boolean | undefined;
    canRotateAboutY?: boolean | undefined;
    canRotateAboutZ?: boolean | undefined;

    [key: string]: any;
}

export interface NullableOfRestraint {
    canTranslateAlongX: boolean;
    canTranslateAlongY: boolean;
    canTranslateAlongZ: boolean;
    canRotateAboutX: boolean;
    canRotateAboutY: boolean;
    canRotateAboutZ: boolean;

    [key: string]: any;
}

export interface Point {
    x: number;
    y: number;
    z: number;
    lengthUnit: number;

    [key: string]: any;
}

export interface PointLoad {
    id: number;
    nodeId: number;
    loadCaseId: number;
    force: Force;
    direction: Vector3;

    [key: string]: any;
}

export interface PointLoadData {
    nodeId: number;
    loadCaseId: number;
    force: Force;
    direction: Vector3;

    [key: string]: any;
}

export interface PointLoadResponse {
    modelId: string;
    id: number;
    nodeId: number;
    loadCaseId: number;
    force: Force;
    direction: Vector3;

    [key: string]: any;
}

export interface ProposalIssue {
    id: number;
    proposedId: ProposedID;
    objectType: number;
    message: string;
    severity: number;
    code: number;

    [key: string]: any;
}

export interface ProposalIssueData {
    proposedId: ProposedID;
    objectType: number;
    message: string;
    severity: number;
    code: number;

    [key: string]: any;
}

export interface ProposedID {
    existingId: number | undefined;
    proposedId: number | undefined;

    [key: string]: any;
}

export interface ProposedID2 {
    existingId: number | undefined;
    proposedId: number | undefined;

    [key: string]: any;
}

export interface PutElement1dRequest {
    id: number;
    startNodeId: number;
    endNodeId: number;
    materialId: number;
    sectionProfileId: number;
    sectionProfileRotation?: NullableOfAngle | undefined;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface PutMaterialRequest {
    id?: number;
    modulusOfElasticity: number;
    modulusOfRigidity: number;
    pressureUnit: number;

    [key: string]: any;
}

export interface PutMomentLoadRequest {
    id?: number;
    nodeId: number;
    loadCaseId: number;
    torque: Torque;
    axisDirection: Vector3;

    [key: string]: any;
}

export interface PutNodeRequest {
    id: number;
    locationPoint: Point;
    restraint: Restraint;
    metadata?: { [key: string]: string; } | undefined;

    [key: string]: any;
}

export interface PutPointLoadRequest {
    id: number;
    nodeId: number;
    loadCaseId: number;
    force: Force;
    direction: Vector3;

    [key: string]: any;
}

export interface PutSectionProfileRequest {
    id: number;
    area: number;
    strongAxisMomentOfInertia: number;
    weakAxisMomentOfInertia: number;
    polarMomentOfInertia: number;
    strongAxisPlasticSectionModulus: number;
    weakAxisPlasticSectionModulus: number;
    strongAxisShearArea?: number | undefined;
    weakAxisShearArea?: number | undefined;
    lengthUnit: number;
    name: string;

    [key: string]: any;
}

export interface Ratio {
    value: number;
    unit: number;

    [key: string]: any;
}

export interface Restraint {
    canTranslateAlongX: boolean;
    canTranslateAlongY: boolean;
    canTranslateAlongZ: boolean;
    canRotateAboutX: boolean;
    canRotateAboutY: boolean;
    canRotateAboutZ: boolean;

    [key: string]: any;
}

export interface ResultSet {
    id: number;
    modelId: string;
    nodeResults?: NodeResultResponse[] | undefined;
    element1dResults?: Element1dResultResponse[] | undefined;

    [key: string]: any;
}

export interface ResultSetResponse {
    id: number;
    modelId: string;
    nodeResults?: NodeResultResponse[] | undefined;
    element1dResults?: Element1dResultResponse[] | undefined;

    [key: string]: any;
}

export interface RunDsmRequest {
    unitsOverride?: string | undefined;
    loadCombinationIds?: number[] | undefined;

    [key: string]: any;
}

export interface SectionProfileData {
    area: number;
    strongAxisMomentOfInertia: number;
    weakAxisMomentOfInertia: number;
    polarMomentOfInertia: number;
    strongAxisPlasticSectionModulus: number;
    weakAxisPlasticSectionModulus: number;
    strongAxisShearArea?: number | undefined;
    weakAxisShearArea?: number | undefined;
    lengthUnit: number;
    name: string;

    [key: string]: any;
}

export interface SectionProfileFromLibrary {
    id: number;
    library: number;
    name: string;

    [key: string]: any;
}

export interface SectionProfileFromLibraryData {
    library: number;
    name: string;

    [key: string]: any;
}

export interface SectionProfileResponse {
    id: number;
    modelId: string;
    name: string;
    area: number;
    strongAxisMomentOfInertia: number;
    weakAxisMomentOfInertia: number;
    polarMomentOfInertia: number;
    strongAxisPlasticSectionModulus: number;
    weakAxisPlasticSectionModulus: number;
    strongAxisShearArea: number | undefined;
    weakAxisShearArea: number | undefined;
    lengthUnit: number;

    [key: string]: any;
}

export interface ShearDiagramResponse {
    globalShearDirection: Vector3;
    lengthUnit: number;
    forceUnit: number;
    elementLength: Length;
    modelId: string;
    resultSetId: number;
    element1dId: number;
    intervals: DiagramConsistentIntervalResponse[];

    [key: string]: any;
}

export interface Torque {
    value: number;
    unit: number;

    [key: string]: any;
}

export interface UnitSettings {
    lengthUnit: number;
    forceUnit: number;
    angleUnit?: number;

    [key: string]: any;
}

export interface UpdateNodeRequest {
    id: number;
    locationPoint?: NullableOfPartialPoint | undefined;
    restraint?: NullableOfPartialRestraint | undefined;

    [key: string]: any;
}

export interface Vector3 {
    x: number;
    y: number;
    z: number;

    [key: string]: any;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}