@using BeamOS.WebApp.Client.Features.KeyBindings.UndoRedo
@using BeamOS.WebApp.Client.State
@using BeamOs.CodeGen.Apis.EditorApi
@using BeamOs.ApiClient
@using BeamOs.Contracts.Common
@using BeamOs.Contracts.PhysicalModel.Model
@using BeamOs.IntegrationEvents
@using BeamOs.IntegrationEvents.Common
@using BeamOs.IntegrationEvents.PhysicalModel.Nodes
@using BeamOs.WebApp.EditorActionsAndEvents.Nodes
@using Fluxor.Blazor.Web.Components
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.Json

@rendermode InteractiveAuto

@inherits FluxorComponent
@implements IDisposable
@implements IAsyncDisposable

@inject IApiAlphaClient analysisApiClient
@inject EditorApiProxyFactory editorApiAlphaFactory
@inject UndoRedoFunctionality UndoRedo
@inject HistoryManager History
@inject NavigationManager NavigationManager
@inject IDispatcher Dispatcher

<MudContainer MaxWidth="MaxWidth.False" Gutters="false" Class=@($"relative {@Class}")>
    <MudPaper Class="h-full w-full absolute z-0"></MudPaper>
    @* <div class="bg-gray-900 w-full h-full absolute"></div> *@
    <canvas id="@elementId" class="h-full w-full absolute z-1"></canvas>
    <MudOverlay Absolute="true" @bind-Visible="@isLoading">
        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.Center">
            <div class="rounded animate-spin ease duration-300 w-10 h-10 border-4 border-white"></div>
            <h2 class="px-3 font-bold text-white"> @loadingText ...</h2>
        </MudStack>
    </MudOverlay>
</MudContainer>

@code {
    [Parameter]
    public string? Class { get; set; }

    private bool isLoading = true;
    private string loadingText = "Loading beamOS editor";
    public string elementId { get; } = "id" + Guid.NewGuid().ToString("N");
    public IEditorApiAlpha? EditorApiAlpha { get; private set; }
    const string physicalModelId = "00000000-0000-0000-0000-000000000000";

    private HubConnection hubConnection;

    private List<IIntegrationEvent> integrationEvents = [];

    protected override async Task OnInitializedAsync()
    {
        hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri(IStructuralAnalysisHubClient.HubEndpointPattern))
                .Build();

        hubConnection.On<System.Text.Json.JsonElement>("StructuralAnalysisIntegrationEventFired", @event =>
        {
            if (@event.TryGetProperty("fullType", out var property))
            {
                Type? eventType = Type.GetType($"{property.ToString()},BeamOs.IntegrationEvents");
                var strongEvent = JsonSerializer.Deserialize(@event, eventType, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true });


                this.Dispatcher.Dispatch(new StatefulIntegrationEvent(){
                        IntegrationEvent = (IIntegrationEvent)strongEvent,
                        DbUpdated = true
                });
            }
        });

        await hubConnection.StartAsync();
        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            isLoading = true;
            EditorApiAlpha ??= await editorApiAlphaFactory.Create(elementId);
            // SubscribeToEditorActions(EditorApiAlpha);

            this.SubscribeToAction<StatefulIntegrationEvent>(async e => await HandleStatefulIntegrationEvent(e));
            this.SubscribeToAction<IIntegrationEvent>(e =>
            {
                Console.WriteLine(e);
            });

            loadingText = "Fetching Data";
            StateHasChanged();
            await LoadModel(physicalModelId);
            isLoading = false;
            StateHasChanged();
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    public async Task LoadModel(string modelId)
    {
        ModelResponseHydrated response = await analysisApiClient
            .GetModelHydratedAsync(modelId, PreconfiguredUnits.N_M);
        var x = await EditorApiAlpha.CreateModelHydratedAsync(response);
    }

    public void Dispose()
    {
        UndoRedo?.Dispose();
        // obj?.Dispose();
    }


    private async Task HandleStatefulIntegrationEvent(StatefulIntegrationEvent statefulIntegrationEvent)
    {
        if (this.EventIsServerResponseToUserInteraction(statefulIntegrationEvent))
        {
            return;
        }

        // if db is not updated, then the event originated from the client, not the server
        if (!statefulIntegrationEvent.DbUpdated)
        {
            this.integrationEvents.Add(statefulIntegrationEvent.IntegrationEvent);
        }

        switch (statefulIntegrationEvent.IntegrationEvent)
        {
            case NodeMovedEvent nodeMovedEvent:
                if (!statefulIntegrationEvent.EditorUpdated)
                {
                    await this.EditorApiAlpha.ReduceNodeMovedEventAsync(nodeMovedEvent);  
                }
                if (!statefulIntegrationEvent.DbUpdated)
                {
                    await this.analysisApiClient.PatchNodeAsync(new()
                        {
                            NodeId = nodeMovedEvent.NodeId.ToString(),
                            LocationPoint = new()
                            {
                                LengthUnit = "Meter",
                                XCoordinate = nodeMovedEvent.NewLocation.X,
                                YCoordinate = nodeMovedEvent.NewLocation.Y,
                                ZCoordinate = nodeMovedEvent.NewLocation.Z
                            }
                        }, nodeMovedEvent.NodeId.ToString());
                }
                break;
        }
    }

    private bool EventIsServerResponseToUserInteraction(StatefulIntegrationEvent statefulIntegrationEvent)
    {
        if (!statefulIntegrationEvent.DbUpdated)
        {
            return false;
        }

        for (int i = 0; i < this.integrationEvents.Count; i++)
        {
            // compare with .Equals() because we need to compare with the value object comparison
            if (this.integrationEvents[i].Equals(statefulIntegrationEvent.IntegrationEvent))
            {
                this.integrationEvents.RemoveAt(i);
                return true;
            }
        }

        return false;
    }

    protected override async ValueTask DisposeAsyncCore(bool disposing)
    {
        await this.hubConnection.DisposeAsync();
        await base.DisposeAsyncCore(disposing);
    }

    [FeatureState]
    public record EditorComponentState(bool IsLoading, string LoadingText, ModelResponse? visibleModel)
    {
        private EditorComponentState()
            : this(true, "Loading beamOS editor", null) { }
    }
}
